#+OPTIONS: toc:nil
#+OPTIONS: ^:nil

* About
  In this file I organize parts of python code that are of interest to me. org-format is used as it allows me to tangle Python-files from emacs from where I do my version control too. The python-files in this repo are exported from this file.
  The github-repo itself is set to public for convenience and not for suggesting usage or expectations about contentual stability.
** dictionary of matrix-lists
   Making a dictionary with 52 keys and a list of 100 200x200 numpy-array-objects (matrices with fraction-values). This version requires numpy to be in the environment. If I make a larger value-object (eg 100 300x300, or 1000 100x100 matrices), my laptop runs out of its 8GB memory and kills the process at normal usage with graphical browser on.





*** numpy-approach
    Outside org this script can be run with ~python3 matrix_dict_creator_numpy.py~.
   #+NAME: matrix-dict-creator-numpy
   #+HEADER: :var OUTPUT="../matrix_dict_numpy.p" :var KEYLEN=5 :var NKEYS=52 :var NMATRIX=100 :var MATRIXX=200 :var MATRIXY=200 
   #+begin_src python :results output :exports both :tangle "./matrix_dict_creator_numpy.py"
import fractions
import numpy
import pickle
import random
import string
import time

START_TIME = time.time()
KEYLENGTH = KEYLEN
KEYCOUNT = NKEYS
MATRIXCOUNT = NMATRIX
XMATRIX = MATRIXX
YMATRIX = MATRIXY
OUTFILE = OUTPUT
KEYLIST = []
for KEYSTRING in range(KEYCOUNT):
    KEYLIST.append(''.join(random.choice(string.ascii_letters) \
  			 for LETTER in range(KEYLENGTH)))
THE_DICT = dict.fromkeys(KEYLIST)
print("%s seconds for dict-initiation" % (time.time() - START_TIME))
START_TIME_DICT_CREATION = time.time()
for KEY in THE_DICT.keys():
    VALUE_LIST = []
    for MATRIX in range(MATRIXCOUNT): VALUE_LIST.append(numpy.full((XMATRIX,YMATRIX), \
  								 fractions.Fraction(2,3)))
    THE_DICT[KEY] = VALUE_LIST
print("%s seconds for dict-creation" % (time.time() - START_TIME_DICT_CREATION))
START_TIME_PICKLE = time.time()
with open(OUTFILE, "wb") as PICKLE_DESTINATION:
    pickle.dump(THE_DICT, PICKLE_DESTINATION)
print("%s seconds for pickling" % (time.time() - START_TIME_PICKLE))
START_TIME_QUERY = time.time()
THE_DICT[list(THE_DICT.keys())[random.randrange(len(THE_DICT.keys()))]]
print("%s seconds for random key query" % (time.time() - START_TIME_QUERY))
print("%s seconds total runtime" % (time.time() - START_TIME))
   #+end_src

   #+RESULTS: matrix-dict-creator-numpy
   : 0.00021719932556152344 seconds for dict-initiation
   : 1.2198333740234375 seconds for dict-creation
   : 9.670838117599487 seconds for pickling
   : 2.6464462280273438e-05 seconds for random key query
   : 10.890970945358276 seconds total runtime

   This is the loader for the created dictionary. It can be run with ~python3 matrix_dict_loader_numpy.py~.

   #+NAME: matrix-dict-loader-numpy
   #+HEADER: :var INPUT="../matrix_dict_numpy.p" 
   #+begin_src python :results output :exports both :tangle "./matrix_dict_loader_numpy.py"
import fractions
import numpy
import pickle
import random
import string
import time

INFILE = INPUT
START_TIME = time.time()
with open(INFILE, "rb") as PICKLE_ORIGIN:
    THE_DICT = pickle.load(PICKLE_ORIGIN)
print("%s seconds for pickle-loading" % (time.time() - START_TIME))
START_TIME_EXTRACT = time.time()
THE_DICT[list(THE_DICT.keys())[random.randrange(len(THE_DICT.keys()))]]
print("%s seconds for entry query" % (time.time() - START_TIME_EXTRACT))
print("%s seconds total runtime" % (time.time() - START_TIME))
   #+end_src

   #+RESULTS: matrix-dict-loader-numpy
   : 7.346083402633667 seconds for pickle-loading
   : 1.8835067749023438e-05 seconds for entry query
   : 7.3461291790008545 seconds total runtime

   And this is the created pickle-file.

   #+NAME: check-numpy-matrix-dict-pickle
   #+HEADER: :var INPUT="../matrix_dict_numpy.p" 
   #+begin_src shell :results output :exports both
INFILE=$INPUT
ls -lha $INFILE
   #+end_src

   #+RESULTS: check-numpy-matrix-dict-pickle
   : -rw-r--r-- 1 daniel users 990M 28. Jun 22:19 ../matrix_dict_numpy.p


*** symbolic approach
   This is an approach that calculates the nullspaces for all given matrices and returns them under the same key from a second dictionary as a matrix of tuples. sympy is used for the nullspace calculations. All dict items are plain python.  Tuples and sympy-Rationals are interchanged where needed, as storing the sympy-objects in a dictionary did not prove performant. This code calculates the nullspaces of the individual dictionary keys in parallel, by default using all available cpus.
   #+NAME: matrix-dict-creator-lists-json-nullspace
   #+HEADER: :var OUTPUT="../matrix_dict.json" :var KEYLEN=5 :var NKEYS=52 :var NMATRIX=10 :var MATRIXX=200 :var MATRIXY=200 :var NULLDICT="../matrix_dict_nullspaces.json" :var INIT_NUM=2 :var INIT_DENOM=3 
   #+begin_src python :results output :exports both :tangle "./matrix_dict_creator_lists_json_nullspace.py"
import functools
import itertools
import json
import multiprocessing
import os
import random
import string
import time
import sympy


# define values
KEYCOUNT = NKEYS
MATRIXCOUNT = NMATRIX
XMATRIX = MATRIXX
YMATRIX = MATRIXY
OUTFILE = OUTPUT
OUTFILE_NULLDICT = NULLDICT
INIT_FRACTION_VALUE = INIT_NUM,INIT_DENOM

# define functions
def create_keylist(KEYCOUNT, KEYLENGTH = 5):
    KEYLIST = []
    for KEYSTRING in range(KEYCOUNT):
        KEYLIST.append(''.join(random.choice(string.ascii_letters) for LETTER in range(KEYLENGTH)))
    return tuple(KEYLIST)

def create_sample_value_matrix(YMATRIX, XMATRIX=YMATRIX, VALUE=(2,3)):
    MATRIX = []
    for ROW in range(YMATRIX):
        MATRIX_ROW = []
        for COLUMN in range(XMATRIX):
            MATRIX_ROW.append(VALUE)
        MATRIX.append(MATRIX_ROW)
    return MATRIX

def create_list_of_matrices(MATRIX, MATRIXCOUNT=5):
    LIST_OF_MATRICES = []
    for TO_BE_ADDED in range(MATRIXCOUNT):
        LIST_OF_MATRICES.append(MATRIX)
    return LIST_OF_MATRICES

def create_dict(KEYLIST):
    DICT = dict.fromkeys(KEYLIST)
    return DICT

def detuple_and_sympyfy_value_matrix(MATRIX):
    NEW_MATRIX = []
    for ROW in MATRIX:
        NEW_MATRIX_ROW = []
        for TUPLE in ROW:
            NEW_MATRIX_ROW.append(sympy.Rational(int(TUPLE[0]), int(TUPLE[1])))
        NEW_MATRIX.append(NEW_MATRIX_ROW)
    return NEW_MATRIX

def calculate_nullspaces_and_retuple_matrix(MATRIX):
    '''calculates the nullspace vectors of a given matrix
    and returns a list of vectors'''
    NULLSPACE_LIST_SYMPY = sympy.Matrix(MATRIX).nullspace()
    NULLSPACE_VECTORLIST =[]
    for VECTOR_MATRIX in NULLSPACE_LIST_SYMPY:
        TUPLED_VALUES = []
        for VALUE in VECTOR_MATRIX:
            if type(VALUE) == "sympy.core.numbers.Rational":
                RECOVERED_TUPLE = int(VALUE.p),int(VALUE.q)
            else:
                RECOVERED_TUPLE = int(VALUE),1
            TUPLED_VALUES.append(RECOVERED_TUPLE)
        NULLSPACE_VECTORLIST.append(TUPLED_VALUES)
    return NULLSPACE_VECTORLIST

def fill_dict(MATRIX_DICT_MULTI, KEY, MATRIXLIST):
    '''creates a dictionary with a list of matrices appended
    to given key. meant to be run within a multiprocessing
    Manager that provides the dictionary'''
    MATRIX_DICT_MULTI[KEY] = MATRIXLIST
    return MATRIX_DICT_MULTI

def save_to_json(DICT,OUTFILE):
    with open(OUTFILE, "w") as JSON_DESTINATION:
        json.dump(DICT, JSON_DESTINATION)
        
def check_query_time(DICT):
    DICT[list(DICT.keys())[random.randrange(len(DICT.keys()))]]

def check_file_size(FILE):
    print("Filesize of {} {} MB\n".format(FILE,os.path.getsize(FILE)/(1024**2)))

# dependent functions

def calculate_nullspace_list(MATRIX_LIST):
    '''calculates the nullspaces of the matrices in 
    a given list of matrices and returns them as a list of list of 
    vectors'''
    NULLSPACE_LIST = []
    for MATRIX in MATRIX_LIST:
        DETUPLED = detuple_and_sympyfy_value_matrix(MATRIX)
        CALCULATED_RETUPLED = calculate_nullspaces_and_retuple_matrix(DETUPLED)
        NULLSPACE_LIST.append(CALCULATED_RETUPLED)
    return NULLSPACE_LIST

def calculate_nullspaces(NULLSPACE_DICT_MULTI, KEY, MATRIX_DICT):
    '''takes a dictionary with list of matrices and 
    returns them as dict with resulting nullspace-vectors. the
    output dictionary is meant to be provided by a multiprocessing Manager'''
    NULLSPACE_DICT_MULTI[KEY] = calculate_nullspace_list(MATRIX_DICT[KEY])
    return NULLSPACE_DICT_MULTI


# program

def main():
    START_TIME = time.time()
    KEYLIST = create_keylist(KEYCOUNT)
    VALUE_MATRIX = create_sample_value_matrix(YMATRIX)
    MATRIX_LIST = create_list_of_matrices(VALUE_MATRIX)
    NULLSPACE_LIST = calculate_nullspace_list(MATRIX_LIST)
    START_TIME_DICT_FILL = time.time()
    MANAGER_01 = multiprocessing.Manager()
    MATRIX_DICT_M = MANAGER_01.dict()
    JOBS_01 = [multiprocessing.Process(target=fill_dict, args=(MATRIX_DICT_M, KEY, MATRIX_LIST)) for KEY in KEYLIST]
    _ = [PROCESS.start() for PROCESS in JOBS_01]
    _ = [PROCESS.join() for PROCESS in JOBS_01]
    MATRIX_DICT = dict(MATRIX_DICT_M)
    print("loading dict with array of matrices: {} seconds\n".format(time.time() - START_TIME_DICT_FILL))
    #print(MATRIX_DICT)
    #print("")
    START_TIME_NULLSPACES = time.time()
    MANAGER_02 = multiprocessing.Manager()
    NULLSPACE_DICT_M = MANAGER_02.dict()
    JOBS_02 = [multiprocessing.Process(target=calculate_nullspaces, args=(NULLSPACE_DICT_M, KEY, MATRIX_DICT)) for KEY in KEYLIST]
    _ = [PROCESS.start() for PROCESS in JOBS_02]
    _ = [PROCESS.join() for PROCESS in JOBS_02]
    NULLSPACE_DICT = dict(NULLSPACE_DICT_M)
    print("nullspace calculation time: {} seconds\n".format(time.time() - START_TIME_NULLSPACES))
    #print(NULLSPACE_DICT)
    #print("")
    START_TIME_SAVING_DICTS = time.time()
    with multiprocessing.Pool() as POOL:
        POOL.starmap(save_to_json, [(MATRIX_DICT,OUTFILE),(NULLSPACE_DICT,OUTFILE_NULLDICT)])
    print("time for saving matrix dict and nullspace dict: {} seconds\n".format(time.time() - START_TIME_SAVING_DICTS))
    START_TIME_QUERIES = time.time()
    for DICT in [MATRIX_DICT,NULLSPACE_DICT]:
        check_query_time(DICT)
# this does not enhance speed, as pool-creation takes about 1 second. might be handy with multiple queries though.
#    with multiprocessing.Pool() as POOL:
#        POOL.starmap(check_query_time, [(MATRIX_DICT,),(NULLSPACE_DICT,)])
    print("time for random query in both dictionaries: {} seconds\n".format(time.time() - START_TIME_QUERIES))
    START_TIME_SIZECHECK = time.time()
    with multiprocessing.Pool() as POOL:
        POOL.starmap(check_file_size, [(OUTFILE,),(OUTFILE_NULLDICT,)])
    print("total runtime: {} seconds\n".format(time.time() - START_TIME))


# program execution

if __name__=="__main__":
    main()

   #+end_src




   
   FURTHER: The nullspace-result is a list of sympy-Matrices with one column.  This column contains numbers of the class sympy.core.numbers.Rational and sympy.core.numbers.Integer. Getting all these into integer-tuple-format could need a function.  

   


