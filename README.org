#+OPTIONS: toc:nil
#+OPTIONS: ^:nil

* About
  In this file I organize parts of python code that are of interest to me. org-format is used as it allows me to tangle Python-files from emacs from where I do my version control too. The python-files in this repo are exported from this file.
 The github-repo itself is set to public for convenience and not for suggesting usage or expectations about contentual stability.
** structures
*** dictionary of matrix-lists
    Making a dictionary with 52 keys and a list of 100 200x200 numpy-array-objects (matrices with fraction-values). This version requires numpy to be in the environment. If I make a larger value-object (eg 100 300x300, or 1000 100x100 matrices), my laptop runs out of its 8GB memory and kills the process at normal usage with graphical browser on. It can be run with ~python3 numpy_matrix_dict_creator.py~.
    #+NAME: numpy-matrix-dict-creator
    #+HEADER: :var OUTPUT="../numpy_matrix_dict.p" :var KEYLEN=5 :var NKEYS=52 :var NMATRIX=100 :var MATRIXX=200 :var MATRIXY=200 
    #+begin_src python :results output :exports both :tangle "./numpy_matrix_dict_creator.py"
import fractions
import numpy
import pickle
import random
import string
import time

START_TIME = time.time()
KEYLENGTH = KEYLEN
KEYCOUNT = NKEYS
MATRIXCOUNT = NMATRIX
XMATRIX = MATRIXX
YMATRIX = MATRIXY
OUTFILE = OUTPUT
KEYLIST = []
for KEYSTRING in range(KEYCOUNT):
    KEYLIST.append(''.join(random.choice(string.ascii_letters) \
  			 for LETTER in range(KEYLENGTH)))
THE_DICT = dict.fromkeys(KEYLIST)
print("%s seconds for dict-initiation" % (time.time() - START_TIME))
START_TIME_DICT_CREATION = time.time()
for KEY in THE_DICT.keys():
    VALUE_LIST = []
    for MATRIX in range(MATRIXCOUNT): VALUE_LIST.append(numpy.full((XMATRIX,YMATRIX), \
  								 fractions.Fraction(2,3)))
    THE_DICT[KEY] = VALUE_LIST
print("%s seconds for dict-creation" % (time.time() - START_TIME_DICT_CREATION))
START_TIME_PICKLE = time.time()
with open(OUTFILE, "wb") as PICKLE_DESTINATION:
    pickle.dump(THE_DICT, PICKLE_DESTINATION)
print("%s seconds for pickling" % (time.time() - START_TIME_PICKLE))
START_TIME_QUERY = time.time()
THE_DICT[list(THE_DICT.keys())[random.randrange(len(THE_DICT.keys()))]]
print("%s seconds for random key query" % (time.time() - START_TIME_QUERY))
print("%s seconds total runtime" % (time.time() - START_TIME))
    #+end_src

    #+RESULTS: numpy-matrix-dict-creator
    : 0.00024271011352539062 seconds for dict-initiation
    : 1.2199208736419678 seconds for dict-creation
    : 9.870619773864746 seconds for pickling
    : 2.47955322265625e-05 seconds for random key query
    : 11.09087085723877 seconds total runtime

    This is the loader for the created dictionary. It can be run with ~python3 numpy_matrix_dict_loader.py~.

    #+NAME: numpy-matrix-dict-loader
    #+HEADER: :var INPUT="../numpy_matrix_dict.p" 
    #+begin_src python :results output :exports both :tangle "./numpy_matrix_dict_loader.py"
      import fractions
      import numpy
      import pickle
      import random
      import string
      import time

      INFILE = INPUT
      START_TIME = time.time()
      with open(INFILE, "rb") as PICKLE_ORIGIN:
	  THE_DICT = pickle.load(PICKLE_ORIGIN)
      print("%s seconds for pickle-loading" % (time.time() - START_TIME))
      START_TIME_EXTRACT = time.time()
      THE_DICT[list(THE_DICT.keys())[random.randrange(len(THE_DICT.keys()))]]
      print("%s seconds for entry query" % (time.time() - START_TIME_EXTRACT))
      print("%s seconds total runtime" % (time.time() - START_TIME))
    #+end_src

    #+RESULTS: numpy-matrix-dict-loader
    : 9.956590414047241 seconds for pickle-loading
    : 1.9311904907226562e-05 seconds for entry query
    : 9.956644535064697 seconds total runtime

    And this is the created pickle-file.

    #+NAME: check-numpy-matrix-dict-pickle
    #+HEADER: :var INPUT="../numpy_matrix_dict.p" 
    #+begin_src shell :results output :exports both
      INFILE=$INPUT
      ls -lha $INFILE
    #+end_src

    #+RESULTS: check-numpy-matrix-dict-pickle
    : -rw-r--r-- 1 daniel users 990M 28. Jun 01:31 ../numpy_matrix_dict.p

    The following is for comparison reasons if the numpy-array-object brings speed enhancements compared to a list-of-lists implementation.

    #+NAME: matrix-dict-creator-lists
    #+HEADER: :var OUTPUT="../list_matrix_dict.p" :var KEYLEN=5 :var NKEYS=52 :var NMATRIX=10 :var MATRIXX=200 :var MATRIXY=200 
    #+begin_src python :results output :exports both :tangle "./matrix_dict_creator_lists.py"
import fractions
import pickle
import random
import string
import time

START_TIME = time.time()
KEYLENGTH = KEYLEN
KEYCOUNT = NKEYS
MATRIXCOUNT = NMATRIX
XMATRIX = MATRIXX
YMATRIX = MATRIXY
OUTFILE = OUTPUT
KEYLIST = []
for KEYSTRING in range(KEYCOUNT):
    KEYLIST.append(''.join(random.choice(string.ascii_letters) \
    		       for LETTER in range(KEYLENGTH)))
THE_DICT = dict.fromkeys(KEYLIST)
print("%s seconds for dict-initiation" % (time.time() - START_TIME))

START_TIME_DICT_CREATION = time.time()
for KEY in THE_DICT.keys():
    VALUE_LIST = []
    for MATRIX_COUNT in range(MATRIXCOUNT):
        MATRIX = []
        for ROW in range(YMATRIX):
            MATRIX_ROW = []
            for COLUMN in range(XMATRIX):
                MATRIX_ROW.append(fractions.Fraction(2,3))
            MATRIX.append(MATRIX_ROW)
        VALUE_LIST.append(MATRIX)
    THE_DICT[KEY] = VALUE_LIST
print("%s seconds for dict-creation" % (time.time() - START_TIME_DICT_CREATION))

START_TIME_PICKLE = time.time()
with open(OUTFILE, "wb") as PICKLE_DESTINATION:
    pickle.dump(THE_DICT, PICKLE_DESTINATION)
print("%s seconds for pickling" % (time.time() - START_TIME_PICKLE))
START_TIME_QUERY = time.time()
THE_DICT[list(THE_DICT.keys())[random.randrange(len(THE_DICT.keys()))]]
print("%s seconds for random key query" % (time.time() - START_TIME_QUERY))
print("%s seconds total runtime" % (time.time() - START_TIME))
    #+end_src

    #+RESULTS: matrix-dict-creator-lists
    : 0.0002124309539794922 seconds for dict-initiation
    : 34.86447238922119 seconds for dict-creation
    : 39.02522039413452 seconds for pickling
    : 2.47955322265625e-05 seconds for random key query
    : 73.88999128341675 seconds total runtime


    OK, obviously numpy helps quite a lot. It is not as hopeless as doing the same with sympy-matrices, but still a lot slower than getting the same values into a dict with numpy-matrices. At least with the approach from above. Let's check the filesize.

    
    #+NAME: check-list-matrix-dict-pickle
    #+HEADER: :var INPUT="../list_matrix_dict.p" 
    #+begin_src shell :results output :exports both
      INFILE=$INPUT
      ls -lha $INFILE
    #+end_src

    #+RESULTS: check-list-matrix-dict-pickle
    : -rw-r--r-- 1 daniel users 239M 28. Jun 21:42 ../list_matrix_dict.p

    The creation process is about 35 times slower, the pickling process 4 times. The resulting file itself is only a quarter of the comparable numpy-file.
